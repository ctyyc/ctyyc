## 자바스크립트의 동작원리: 엔진, 런타임, 호출 스택

### 자바스크립트 엔진
	- 주요 구성요소
	Memory Heap : 메모리 할당이 일어나는 곳
	Call Stack : 코드 실행에 따라 호출 스택이 쌓이는 곳

### 런타임
	자바스크립트 엔진, Web APIs(DOM, AJAX, Timeout 등), Event Loop

### 호출 스택(Call Stack)
	- 자바스크립트는 싱글 쓰레드 기반의 언어이다. 즉, 호출 스택이 하나이며, 한번에 한 작업만 처리 가능하다.
	- 호출 스택을 통해 현재 실행되는 위치를 알 수 있고, 리턴 값을 돌려줄 때, 해당 함수를 호출 스택에서 제거한다.
	- 호출 스택의 각 단계를 스택 프레임(Stack Frame)이라고 한다.
	- 호출 스택의 최대 허용치를 넘기면 RangeError가 발생한다.

### 동시성(Concurrency) & 이벤트 루프(Event Loop)
	호출 스택에 처리 시간이 오래 걸리는 함수는 비동기 콜백으로 해결할 수 있다.

<br/>
<hr/>

## 함수 선언식 vs 함수 표현식

### 함수 선언식 ex.
```
function 함수명() {
	구현 로직
}
```
### 함수 표현식 ex.
```
var 함수명 = function () {
		구현 로직
};
```

### 차이점
	- 함수 선언식은 호이스팅에 영향을 받지만, 함수 표현식은 호이스팅에 영향을 받지 않는다.
	- 함수 선언식은 코드를 구현한 위치와 관계없이 자바스크립트의 특징인 호이스팅에 따라 브라우저가 자바스크립트를 해석할 때 맨 위로 끌어 올려진다.

### 함수 표현식의 장점
	- 클로저 함수로 사용
	- 콜백 함수로 사용 (다른 함수의 인자로 넘길 수 있음)

<br/>
<hr/>

## Javascript Note

### Javascript 특징
	1) 자바스크립트는 다른 언어와 달리 웹 브라우저에서 실행되기 때문에, 속도가 빠르다. (JSP, APS 등은 웹 서버)
	2) 동적 형변환
	3) 프로토타입 기반 객체 지향(Prototypal Object-Oriented) : 클래스를 통해 객체를 생성하는 것이 아니라, 객체의 특성을 복제하여 객체를 생성한다. 따라서 런타임 중에도 객체의 값을 변경할 수 있다.
	4) 고차 함수 : 함수를 파라미터로 받거나, 함수를 반환할 수 있음

### 자바스크립트 엔진
	자바스크립트 코드를 실행하는 프로그램 혹은 인터프리터

### 객체(Object)
	- 대상의 특성은 객체의 속성(Property), 대상의 동작은 객체의 메소드(Method)
	- 생성자(객체를 생성할 때 최초로 호출되는 함수)를 통해 객체를 생성
	- constructor라는 속성이 생긴다. (어떤 객체를 참조하였는지에 대한 정보 저장)

### 프로토타입을 이용한 상속(재사용성)
	- javascript에서 객체를 선언 시, 프로토타입 객체가 생성됨
	- 생성된 객체들은 이 프로토타입 객체를 참조하는 프로토타입 속성을 갖게됨
	- 상속은 이 프로토타입 객체를 상속받는 것임
	- __ proto __ 속성은 자신을 만들어낸 프로토타입 객체를 참조하는 링크가 있으며, 이 링크를 프로토타입이라고 정의

### Scope(유효 범위)
	- 전역(global)과 지역(local) 스코프로 정의

	- Function-level scope(함수 레벨 스코프) [var 변수]
	- Block-level scope(블록 레벨 스코프) [const, let 변수]

### Scope Chain(유효 범위 체인)
	자신의 스코프에서 찾을 수 없다면 상위 스코프로 이동하는 것

### 정적 범위(Lexical scope)
	자바스크립트에서 스코프는 어디서 호출하는지가 아니라 처음 선언되었을 때에 어떤 스코프에 있는지가 중요하다.

```
var text = 'global';

function foo() {
	console.log(text);
}

function bar() {
	var text = 'bar';	// 이 부분을 text = 'bar' 로 수정해야, bar가 출력됨
	foo();
}

bar();
// global이 출력됨.
```

### 호이스팅(hoisting)
	- 변수 선언을 함수 상단으로 끌어올림 (단, 값을 대입하는 위치는 그대로)
	- 함수 표현식은 호이스팅이 적용 방식이 약간 다름.

### 클로저(Closure)
	- 외부 함수의 실행이 끝나고 외부 함수가 소멸된 이후에도 내부 함수가 외부 함수의 변수에 접근할 수 있는 구조
	- 장점 : 전역 변수의 잘못된 사용 없이 깔끔한 코드 작성을 할 수 있음, 외부에 해당 변수를 노출시키지 않아서 안정성을 보장(캡슐화)
	- 단점 : 클로저로 참조하는 변수는 프로그램 종료 시까지 계속 메모리에 할당되어 있기 때문에, 메모리 누수로 인해 성능 저하의 원인이 될 수도 있으니 신중하게 사용해야 함



<br/>
<br/>
이 글은 '한 눈에 끝내는 Node.js'와 'Captain Pangyo'님의 블로그를 참고하였습니다.